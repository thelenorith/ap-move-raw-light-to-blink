"""
Unit tests for ap_copy_lights.copy_lights module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import pytest
from unittest.mock import patch

from ap_copy_lights import copy_lights, config


class TestCopyFiles:
    """Tests for copy_files function."""

    @patch("ap_copy_lights.copy_lights._copy_file_type")
    @patch("ap_common.delete_empty_directories")
    def test_copy_files_calls_all_file_types(self, mock_delete, mock_copy_type):
        """Test that copy_files processes all file types."""
        source_dir = "/test/source"
        dest_dir = "/test/dest"

        copy_lights.copy_files(source_dir, dest_dir, debug=False, dryrun=False)

        # Should call _copy_file_type for each file type
        assert mock_copy_type.call_count == 4

        # Verify calls for each file type (using keyword arguments)
        file_types_called = [
            mock_call.kwargs["file_type"] for mock_call in mock_copy_type.call_args_list
        ]
        assert "BIAS" in file_types_called
        assert "DARK" in file_types_called
        assert "FLAT" in file_types_called
        assert "LIGHT" in file_types_called

        # Should clean up empty directories
        mock_delete.assert_called_once_with(source_dir, dryrun=False)

    @patch("ap_copy_lights.copy_lights._copy_file_type")
    @patch("ap_common.delete_empty_directories")
    def test_copy_files_with_dryrun(self, mock_delete, mock_copy_type):
        """Test copy_files with dryrun flag."""
        source_dir = "/test/source"
        dest_dir = "/test/dest"

        copy_lights.copy_files(source_dir, dest_dir, debug=False, dryrun=True)

        # Should still process all file types
        assert mock_copy_type.call_count == 4

        # Should pass dryrun to delete_empty_directories
        mock_delete.assert_called_once_with(source_dir, dryrun=True)

    @patch("ap_copy_lights.copy_lights._copy_file_type")
    @patch("ap_common.delete_empty_directories")
    def test_copy_files_with_debug(self, mock_delete, mock_copy_type):
        """Test copy_files with debug flag."""
        source_dir = "/test/source"
        dest_dir = "/test/dest"

        copy_lights.copy_files(source_dir, dest_dir, debug=True, dryrun=False)

        # Should pass debug to _copy_file_type
        for mock_call in mock_copy_type.call_args_list:
            assert mock_call.kwargs["debug"] is True


class TestCopyFileType:
    """Tests for _copy_file_type function."""

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    @patch("pathlib.Path.mkdir")
    def test_copy_file_type_bias(
        self, mock_mkdir, mock_copy_file, mock_normalize, mock_get_metadata, tmp_path
    ):
        """Test copying BIAS files."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        # Mock metadata response
        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "BIAS",
                "camera": "TestCam",
                "date": "2024-01-01",
                "exposureseconds": "1.0",
                "datetime": "2024-01-01_12-00-00",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(tmp_path / "dest" / "normalized.fits")

        copy_lights._copy_file_type(
            source_dir=source_dir,
            dest_dir=dest_dir,
            file_type="BIAS",
            input_pattern=".*",
            recursive=False,
            print_status=False,
            debug=False,
            dryrun=False,
        )

        # Should call get_filtered_metadata with correct filters
        mock_get_metadata.assert_called_once()
        call_kwargs = mock_get_metadata.call_args[1]
        assert call_kwargs["filters"]["type"] == "BIAS"
        assert call_kwargs["recursive"] is False

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    def test_copy_file_type_light_with_blink_dir(
        self, mock_copy_file, mock_normalize, mock_get_metadata, tmp_path
    ):
        """Test copying LIGHT files uses BLINK directory."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        # Mock metadata response
        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "LIGHT",
                "camera": "TestCam",
                "optic": "TestOptic",
                "focal_ratio": "5.0",
                "targetname": "TestTarget",
                "date": "2024-01-01",
                "exposureseconds": "60.0",
                "datetime": "2024-01-01_12-00-00",
                "filter": "UVIR",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(tmp_path / "dest" / "normalized.fits")

        copy_lights._copy_file_type(
            source_dir=source_dir,
            dest_dir=dest_dir,
            file_type="LIGHT",
            input_pattern=".*",
            recursive=True,
            print_status=False,
            debug=False,
            dryrun=False,
        )

        # Should call normalize_filename with BLINK directory
        mock_normalize.assert_called_once()
        call_kwargs = mock_normalize.call_args[1]
        assert call_kwargs["statedir"] == config.DIRECTORY_BLINK

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.copy_file")
    def test_copy_file_type_skips_missing_type(
        self, mock_copy_file, mock_get_metadata, tmp_path, capsys
    ):
        """Test that files without type are skipped."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        # Mock metadata response without type
        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "camera": "TestCam",
            }
        }
        mock_get_metadata.return_value = mock_metadata

        copy_lights._copy_file_type(
            source_dir=source_dir,
            dest_dir=dest_dir,
            file_type="BIAS",
            input_pattern=".*",
            recursive=False,
            print_status=False,
            debug=False,
            dryrun=False,
        )

        # Should not copy file without type
        mock_copy_file.assert_not_called()

        # Should print warning
        captured = capsys.readouterr()
        assert "WARNING" in captured.out
        assert "type not set" in captured.out

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    def test_copy_file_type_dryrun(
        self, mock_copy_file, mock_normalize, mock_get_metadata, tmp_path
    ):
        """Test _copy_file_type with dryrun flag."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "BIAS",
                "camera": "TestCam",
                "date": "2024-01-01",
                "exposureseconds": "1.0",
                "datetime": "2024-01-01_12-00-00",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(tmp_path / "dest" / "normalized.fits")

        copy_lights._copy_file_type(
            source_dir=source_dir,
            dest_dir=dest_dir,
            file_type="BIAS",
            input_pattern=".*",
            recursive=False,
            print_status=False,
            debug=False,
            dryrun=True,
        )

        # Should call copy_file with dryrun=True
        mock_copy_file.assert_called()
        call_kwargs = mock_copy_file.call_args[1]
        assert call_kwargs["dryrun"] is True

    def test_copy_file_type_invalid_type(self):
        """Test that invalid file type raises exception."""
        with pytest.raises(
            copy_lights.UnexpectedImageTypeError, match="unexpected image type"
        ):
            copy_lights._copy_file_type(
                source_dir="/test/source",
                dest_dir="/test/dest",
                file_type="INVALID",
                input_pattern=".*",
                recursive=False,
                print_status=False,
                debug=False,
                dryrun=False,
            )


class TestMain:
    """Tests for main function."""

    @patch("ap_copy_lights.copy_lights.copy_files")
    def test_main_calls_copy_files(self, mock_copy_files):
        """Test that main function calls copy_files with correct arguments."""
        with patch("sys.argv", ["copy_lights.py", "/source", "/dest"]):
            copy_lights.main()

        mock_copy_files.assert_called_once_with(
            source_dir="/source", dest_dir="/dest", debug=False, dryrun=False
        )

    @patch("ap_copy_lights.copy_lights.copy_files")
    def test_main_with_debug_flag(self, mock_copy_files):
        """Test main with --debug flag."""
        with patch("sys.argv", ["copy_lights.py", "/source", "/dest", "--debug"]):
            copy_lights.main()

        mock_copy_files.assert_called_once_with(
            source_dir="/source", dest_dir="/dest", debug=True, dryrun=False
        )

    @patch("ap_copy_lights.copy_lights.copy_files")
    def test_main_with_dryrun_flag(self, mock_copy_files):
        """Test main with --dryrun flag."""
        with patch("sys.argv", ["copy_lights.py", "/source", "/dest", "--dryrun"]):
            copy_lights.main()

        mock_copy_files.assert_called_once_with(
            source_dir="/source", dest_dir="/dest", debug=False, dryrun=True
        )

    @patch("ap_copy_lights.copy_lights.copy_files")
    def test_main_with_both_flags(self, mock_copy_files):
        """Test main with both --debug and --dryrun flags."""
        with patch(
            "sys.argv",
            ["copy_lights.py", "/source", "/dest", "--debug", "--dryrun"],
        ):
            copy_lights.main()

        mock_copy_files.assert_called_once_with(
            source_dir="/source", dest_dir="/dest", debug=True, dryrun=True
        )
