"""
Generated By: Cursor (Claude Sonnet 4.5)

This script moves astrophotography files from a source directory to a destination directory,
organizing them based on FITS header metadata. It processes all file types (BIAS, DARK, FLAT, LIGHT)
and organizes them into the appropriate directory structure.
"""

import argparse
import os
from pathlib import Path
import re

import ap_common
from . import config


class UnexpectedImageTypeError(Exception):
    """Raised when an unexpected image type is encountered."""

    pass


def move_files(
    source_dir: str,
    dest_dir: str,
    debug: bool = False,
    dryrun: bool = False,
    blink_dir: str | None = None,
    accept_dir: str | None = None,
    create_accept: bool = True,
) -> None:
    """
    Moves files from source_dir to dest_dir, organizing them based on FITS header metadata.

    Args:
        source_dir: Source directory containing raw files
        dest_dir: Destination directory for organized files
        debug: Enable debug output
        dryrun: Perform dry run without actually moving files
        blink_dir: Directory name for LIGHT files (default: "10_Blink")
        accept_dir: Directory name for accept subdirectories (default: "accept")
        create_accept: Whether to create accept subdirectories (default: True)
    """
    input_pattern = config.INPUT_PATTERN_ALL

    # Use provided directory names or defaults from config
    blink_directory = blink_dir if blink_dir is not None else config.DIRECTORY_BLINK
    accept_directory = accept_dir if accept_dir is not None else config.DIRECTORY_ACCEPT

    # Process each file type
    file_types = [
        ("BIAS", False, False),  # type, recursive, printStatus
        ("DARK", False, False),
        ("FLAT", False, False),
        ("LIGHT", True, True),  # LIGHT files are recursive and show status
    ]

    for file_type, recursive, print_status in file_types:
        _move_file_type(
            source_dir=source_dir,
            dest_dir=dest_dir,
            file_type=file_type,
            input_pattern=input_pattern,
            recursive=recursive,
            print_status=print_status,
            debug=debug,
            dryrun=dryrun,
            blink_dir=blink_directory,
            accept_dir=accept_directory,
            create_accept=create_accept,
        )

    # Clean up empty directories in source
    print("Cleaning up empty directories...")
    ap_common.delete_empty_directories(source_dir, dryrun=dryrun)


def _move_file_type(
    source_dir: str,
    dest_dir: str,
    file_type: str,
    input_pattern: str,
    recursive: bool,
    print_status: bool,
    debug: bool,
    dryrun: bool,
    blink_dir: str,
    accept_dir: str,
    create_accept: bool,
) -> None:
    """
    Moves files of a specific type from source to destination.

    Args:
        source_dir: Source directory
        dest_dir: Destination directory
        file_type: Type of files to move (BIAS, DARK, FLAT, LIGHT)
        input_pattern: Pattern to match files
        recursive: Whether to search recursively
        print_status: Whether to print status updates
        debug: Enable debug output
        dryrun: Perform dry run
    """
    # Set required properties based on the image type
    required_properties = []
    if file_type == "BIAS" or file_type == "DARK":
        required_properties = [
            "camera",
            "type",
            "date",
            "exposureseconds",
            "datetime",
            "filename",
        ]
    elif file_type == "FLAT":
        required_properties = [
            "camera",
            "type",
            "date",
            "exposureseconds",
            "datetime",
            "filename",
            "optic",
            "focal_ratio",
            "filter",
        ]
    elif file_type == "LIGHT":
        required_properties = [
            "camera",
            "type",
            "date",
            "exposureseconds",
            "datetime",
            "filename",
            "optic",
            "focal_ratio",
            "filter",
            "targetname",
        ]
    else:
        raise UnexpectedImageTypeError(f"unexpected image type: {file_type}")

    # Get metadata for files matching the type
    data = ap_common.get_filtered_metadata(
        dirs=[source_dir],
        patterns=[input_pattern],
        recursive=recursive,
        required_properties=required_properties,
        filters={"type": file_type.upper()},
        debug=debug,
        profileFromPath=False,
        printStatus=print_status,
    )

    if print_status:
        print(f"Moving {file_type} files..", end=".", flush=True)

    # Collect all "target" directories (parent of DATE) so can create "accept" sub-dirs
    target_dirs = set()
    count_files = 0

    for datum in data.values():
        filename_src = datum["filename"]
        statedir = None

        if "type" not in datum:
            print(f"WARNING: type not set in datum, skipping: {datum}")
            continue

        # For LIGHT files, use BLINK directory
        if datum["type"] == "LIGHT":
            statedir = blink_dir

        # Determine destination filename based on metadata
        filename_dest = ap_common.normalize_filename(
            output_directory=dest_dir,
            input_filename=filename_src,
            headers=datum,
            statedir=statedir,
        )

        # Move the file
        ap_common.copy_file(
            from_file=filename_src,
            to_file=filename_dest,
            debug=debug,
            dryrun=dryrun,
        )

        count_files += 1
        if print_status and count_files % 50 == 0:
            print(".", end="", flush=True)

        # Create accept directories for target directories
        if create_accept:
            for t in re.findall("(.*)[\\\\\\/]DATE.*", filename_dest):
                if t not in target_dirs and not dryrun:
                    # Create the accept directory as we go, more idempotent overall (resilient to failures)
                    Path(t + os.sep + accept_dir).mkdir(parents=True, exist_ok=True)
                target_dirs.add(t)

    if print_status:
        print(f"\nMoved {count_files} {file_type} file(s)")


def main() -> None:
    """Main entry point for the command-line interface."""
    parser = argparse.ArgumentParser(
        description="Move files from source directory to destination directory"
    )
    parser.add_argument(
        "source_dir", type=str, help="Source directory containing raw files"
    )
    parser.add_argument(
        "dest_dir", type=str, help="Destination directory for organized files"
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument(
        "--dryrun", action="store_true", help="Perform dry run without moving files"
    )
    parser.add_argument(
        "--blink-dir",
        type=str,
        default=None,
        help='Directory name for LIGHT files (default: "10_Blink")',
    )
    parser.add_argument(
        "--accept-dir",
        type=str,
        default=None,
        help='Directory name for accept subdirectories (default: "accept")',
    )
    parser.add_argument(
        "--no-accept",
        action="store_true",
        help="Do not create accept subdirectories",
    )

    args = parser.parse_args()

    move_files(
        source_dir=args.source_dir,
        dest_dir=args.dest_dir,
        debug=args.debug,
        dryrun=args.dryrun,
        blink_dir=args.blink_dir,
        accept_dir=args.accept_dir,
        create_accept=not args.no_accept,
    )


if __name__ == "__main__":
    main()
