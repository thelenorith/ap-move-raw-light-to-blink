"""
Unit tests for ap_move_lights.move_lights module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
from unittest.mock import patch

from ap_move_lights import move_lights, config


class TestMoveFiles:
    """Tests for move_files function."""

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    @patch("ap_common.delete_empty_directories")
    @patch("pathlib.Path.mkdir")
    def test_move_files_processes_light_files(
        self,
        mock_mkdir,
        mock_delete,
        mock_copy_file,
        mock_normalize,
        mock_get_metadata,
        tmp_path,
    ):
        """Test that move_files processes LIGHT files."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        # Mock metadata response
        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "LIGHT",
                "camera": "TestCam",
                "optic": "TestOptic",
                "focal_ratio": "5.0",
                "targetname": "TestTarget",
                "date": "2024-01-01",
                "exposureseconds": "60.0",
                "datetime": "2024-01-01_12-00-00",
                "filter": "UVIR",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(tmp_path / "dest" / "normalized.fits")

        move_lights.move_files(source_dir, dest_dir, debug=False, dryrun=False)

        # Should call get_filtered_metadata with LIGHT filter and recursive=True
        mock_get_metadata.assert_called_once()
        call_kwargs = mock_get_metadata.call_args[1]
        assert call_kwargs["filters"]["type"] == "LIGHT"
        assert call_kwargs["recursive"] is True
        assert call_kwargs["printStatus"] is True

        # Should call normalize_filename with BLINK directory
        mock_normalize.assert_called_once()
        normalize_kwargs = mock_normalize.call_args[1]
        assert normalize_kwargs["statedir"] == config.DIRECTORY_BLINK

        # Should call copy_file
        mock_copy_file.assert_called_once()

        # Should clean up empty directories
        mock_delete.assert_called_once_with(source_dir, dryrun=False)

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    @patch("ap_common.delete_empty_directories")
    def test_move_files_with_dryrun(
        self, mock_delete, mock_copy_file, mock_normalize, mock_get_metadata, tmp_path
    ):
        """Test move_files with dryrun flag."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "LIGHT",
                "camera": "TestCam",
                "optic": "TestOptic",
                "focal_ratio": "5.0",
                "targetname": "TestTarget",
                "date": "2024-01-01",
                "exposureseconds": "60.0",
                "datetime": "2024-01-01_12-00-00",
                "filter": "UVIR",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(tmp_path / "dest" / "normalized.fits")

        move_lights.move_files(source_dir, dest_dir, debug=False, dryrun=True)

        # Should pass dryrun to copy_file and delete_empty_directories
        mock_copy_file.assert_called_once()
        copy_kwargs = mock_copy_file.call_args[1]
        assert copy_kwargs["dryrun"] is True

        mock_delete.assert_called_once_with(source_dir, dryrun=True)

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    @patch("ap_common.delete_empty_directories")
    def test_move_files_with_debug(
        self, mock_delete, mock_copy_file, mock_normalize, mock_get_metadata, tmp_path
    ):
        """Test move_files with debug flag."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "LIGHT",
                "camera": "TestCam",
                "optic": "TestOptic",
                "focal_ratio": "5.0",
                "targetname": "TestTarget",
                "date": "2024-01-01",
                "exposureseconds": "60.0",
                "datetime": "2024-01-01_12-00-00",
                "filter": "UVIR",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(tmp_path / "dest" / "normalized.fits")

        move_lights.move_files(source_dir, dest_dir, debug=True, dryrun=False)

        # Should pass debug to get_filtered_metadata and copy_file
        get_metadata_kwargs = mock_get_metadata.call_args[1]
        assert get_metadata_kwargs["debug"] is True

        copy_kwargs = mock_copy_file.call_args[1]
        assert copy_kwargs["debug"] is True

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.copy_file")
    def test_move_files_skips_missing_type(
        self, mock_copy_file, mock_get_metadata, tmp_path, capsys
    ):
        """Test that files without type are skipped."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        # Mock metadata response without type
        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "camera": "TestCam",
            }
        }
        mock_get_metadata.return_value = mock_metadata

        move_lights.move_files(source_dir, dest_dir, debug=False, dryrun=False)

        # Should not move file without type
        mock_copy_file.assert_not_called()

        # Should print warning
        captured = capsys.readouterr()
        assert "WARNING" in captured.out
        assert "type not set" in captured.out

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    @patch("pathlib.Path.mkdir")
    def test_move_files_creates_accept_directories(
        self,
        mock_mkdir,
        mock_copy_file,
        mock_normalize,
        mock_get_metadata,
        tmp_path,
    ):
        """Test that accept directories are created for target directories."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        # Mock metadata response with path that includes DATE
        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "LIGHT",
                "camera": "TestCam",
                "optic": "TestOptic",
                "focal_ratio": "5.0",
                "targetname": "TestTarget",
                "date": "2024-01-01",
                "exposureseconds": "60.0",
                "datetime": "2024-01-01_12-00-00",
                "filter": "UVIR",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        # Return a path with DATE in it to trigger accept directory creation
        mock_normalize.return_value = str(
            tmp_path / "dest" / "TestTarget" / "DATE_2024-01-01" / "file1.fits"
        )

        move_lights.move_files(source_dir, dest_dir, debug=False, dryrun=False)

        # Should create accept directory
        # Verify mkdir was called with correct keyword arguments
        mock_mkdir.assert_called()
        # Check that mkdir was called with parents=True and exist_ok=True
        # (The path verification is implicit - if mkdir is called, the accept directory logic ran)
        call_found = False
        for call in mock_mkdir.call_args_list:
            # Handle both new-style (MockCall) and old-style (tuple) call formats
            if hasattr(call, "kwargs"):
                kwargs = call.kwargs
            elif isinstance(call, tuple) and len(call) > 1:
                kwargs = call[1]
            else:
                continue
            if kwargs.get("parents") is True and kwargs.get("exist_ok") is True:
                call_found = True
                break
        assert (
            call_found
        ), "Expected mkdir to be called with parents=True and exist_ok=True"

    @patch("ap_common.get_filtered_metadata")
    @patch("ap_common.normalize_filename")
    @patch("ap_common.copy_file")
    @patch("pathlib.Path.mkdir")
    def test_move_files_no_accept_when_disabled(
        self,
        mock_mkdir,
        mock_copy_file,
        mock_normalize,
        mock_get_metadata,
        tmp_path,
    ):
        """Test that accept directories are not created when create_accept=False."""
        source_dir = str(tmp_path / "source")
        dest_dir = str(tmp_path / "dest")
        os.makedirs(source_dir, exist_ok=True)

        mock_metadata = {
            "file1.fits": {
                "filename": str(tmp_path / "source" / "file1.fits"),
                "type": "LIGHT",
                "camera": "TestCam",
                "optic": "TestOptic",
                "focal_ratio": "5.0",
                "targetname": "TestTarget",
                "date": "2024-01-01",
                "exposureseconds": "60.0",
                "datetime": "2024-01-01_12-00-00",
                "filter": "UVIR",
            }
        }
        mock_get_metadata.return_value = mock_metadata
        mock_normalize.return_value = str(
            tmp_path / "dest" / "TestTarget" / "DATE_2024-01-01" / "file1.fits"
        )

        move_lights.move_files(
            source_dir, dest_dir, debug=False, dryrun=False, create_accept=False
        )

        # Should not create accept directory
        mock_mkdir.assert_not_called()


class TestMain:
    """Tests for main function."""

    @patch("ap_move_lights.move_lights.move_files")
    def test_main_calls_move_files(self, mock_move_files):
        """Test that main function calls move_files with correct arguments."""
        with patch("sys.argv", ["move_lights.py", "/source", "/dest"]):
            move_lights.main()

        mock_move_files.assert_called_once_with(
            source_dir="/source",
            dest_dir="/dest",
            debug=False,
            dryrun=False,
            blink_dir=None,
            accept_dir=None,
            create_accept=True,
        )

    @patch("ap_move_lights.move_lights.move_files")
    def test_main_with_debug_flag(self, mock_move_files):
        """Test main with --debug flag."""
        with patch("sys.argv", ["move_lights.py", "/source", "/dest", "--debug"]):
            move_lights.main()

        mock_move_files.assert_called_once_with(
            source_dir="/source",
            dest_dir="/dest",
            debug=True,
            dryrun=False,
            blink_dir=None,
            accept_dir=None,
            create_accept=True,
        )

    @patch("ap_move_lights.move_lights.move_files")
    def test_main_with_dryrun_flag(self, mock_move_files):
        """Test main with --dryrun flag."""
        with patch("sys.argv", ["move_lights.py", "/source", "/dest", "--dryrun"]):
            move_lights.main()

        mock_move_files.assert_called_once_with(
            source_dir="/source",
            dest_dir="/dest",
            debug=False,
            dryrun=True,
            blink_dir=None,
            accept_dir=None,
            create_accept=True,
        )

    @patch("ap_move_lights.move_lights.move_files")
    def test_main_with_both_flags(self, mock_move_files):
        """Test main with both --debug and --dryrun flags."""
        with patch(
            "sys.argv",
            ["move_lights.py", "/source", "/dest", "--debug", "--dryrun"],
        ):
            move_lights.main()

        mock_move_files.assert_called_once_with(
            source_dir="/source",
            dest_dir="/dest",
            debug=True,
            dryrun=True,
            blink_dir=None,
            accept_dir=None,
            create_accept=True,
        )
