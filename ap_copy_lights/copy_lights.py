"""
Generated By: Cursor (Claude Sonnet 4.5)

This script copies astrophotography files from a source directory to a destination directory,
organizing them based on FITS header metadata. It processes all file types (BIAS, DARK, FLAT, LIGHT)
and organizes them into the appropriate directory structure.
"""

import argparse
import os
from pathlib import Path
import re

import ap_common
from . import config


class UnexpectedImageTypeError(Exception):
    """Raised when an unexpected image type is encountered."""

    pass


def copy_files(
    source_dir: str, dest_dir: str, debug: bool = False, dryrun: bool = False
) -> None:
    """
    Copies files from source_dir to dest_dir, organizing them based on FITS header metadata.

    Args:
        source_dir: Source directory containing raw files
        dest_dir: Destination directory for organized files
        debug: Enable debug output
        dryrun: Perform dry run without actually copying files
    """
    input_pattern = config.INPUT_PATTERN_ALL

    # Process each file type
    file_types = [
        ("BIAS", False, False),  # type, recursive, printStatus
        ("DARK", False, False),
        ("FLAT", False, False),
        ("LIGHT", True, True),  # LIGHT files are recursive and show status
    ]

    for file_type, recursive, print_status in file_types:
        _copy_file_type(
            source_dir=source_dir,
            dest_dir=dest_dir,
            file_type=file_type,
            input_pattern=input_pattern,
            recursive=recursive,
            print_status=print_status,
            debug=debug,
            dryrun=dryrun,
        )

    # Clean up empty directories in source
    print("Cleaning up empty directories...")
    ap_common.delete_empty_directories(source_dir, dryrun=dryrun)


def _copy_file_type(
    source_dir: str,
    dest_dir: str,
    file_type: str,
    input_pattern: str,
    recursive: bool,
    print_status: bool,
    debug: bool,
    dryrun: bool,
) -> None:
    """
    Copies files of a specific type from source to destination.

    Args:
        source_dir: Source directory
        dest_dir: Destination directory
        file_type: Type of files to copy (BIAS, DARK, FLAT, LIGHT)
        input_pattern: Pattern to match files
        recursive: Whether to search recursively
        print_status: Whether to print status updates
        debug: Enable debug output
        dryrun: Perform dry run
    """
    # Set required properties based on the image type
    required_properties = []
    if file_type == "BIAS" or file_type == "DARK":
        required_properties = [
            "camera",
            "type",
            "date",
            "exposureseconds",
            "datetime",
            "filename",
        ]
    elif file_type == "FLAT":
        required_properties = [
            "camera",
            "type",
            "date",
            "exposureseconds",
            "datetime",
            "filename",
            "optic",
            "focal_ratio",
            "filter",
        ]
    elif file_type == "LIGHT":
        required_properties = [
            "camera",
            "type",
            "date",
            "exposureseconds",
            "datetime",
            "filename",
            "optic",
            "focal_ratio",
            "filter",
            "targetname",
        ]
    else:
        raise UnexpectedImageTypeError(f"unexpected image type: {file_type}")

    # Get metadata for files matching the type
    data = ap_common.get_filtered_metadata(
        dirs=[source_dir],
        patterns=[input_pattern],
        recursive=recursive,
        required_properties=required_properties,
        filters={"type": file_type.upper()},
        debug=debug,
        profileFromPath=False,
        printStatus=print_status,
    )

    if print_status:
        print(f"Copying {file_type} files..", end=".", flush=True)

    # Collect all "target" directories (parent of DATE) so can create "accept" sub-dirs
    target_dirs = set()
    count_files = 0

    for datum in data.values():
        filename_src = datum["filename"]
        statedir = None

        if "type" not in datum:
            print(f"WARNING: type not set in datum, skipping: {datum}")
            continue

        # For LIGHT files, use BLINK directory
        if datum["type"] == "LIGHT":
            statedir = config.DIRECTORY_BLINK

        # Determine destination filename based on metadata
        filename_dest = ap_common.normalize_filename(
            output_directory=dest_dir,
            input_filename=filename_src,
            headers=datum,
            statedir=statedir,
        )

        # Copy the file
        ap_common.copy_file(
            from_file=filename_src,
            to_file=filename_dest,
            debug=debug,
            dryrun=dryrun,
        )

        count_files += 1
        if print_status and count_files % 50 == 0:
            print(".", end="", flush=True)

        # Create accept directories for target directories
        for t in re.findall("(.*)[\\\\\\/]DATE.*", filename_dest):
            if t not in target_dirs and not dryrun:
                # Create the accept directory as we go, more idempotent overall (resilient to failures)
                Path(t + os.sep + config.DIRECTORY_ACCEPT).mkdir(
                    parents=True, exist_ok=True
                )
            target_dirs.add(t)

    if print_status:
        print(f"\nCopied {count_files} {file_type} file(s)")


def main() -> None:
    """Main entry point for the command-line interface."""
    parser = argparse.ArgumentParser(
        description="Copy files from source directory to destination directory"
    )
    parser.add_argument(
        "source_dir", type=str, help="Source directory containing raw files"
    )
    parser.add_argument(
        "dest_dir", type=str, help="Destination directory for organized files"
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument(
        "--dryrun", action="store_true", help="Perform dry run without copying files"
    )

    args = parser.parse_args()

    copy_files(
        source_dir=args.source_dir,
        dest_dir=args.dest_dir,
        debug=args.debug,
        dryrun=args.dryrun,
    )


if __name__ == "__main__":
    main()
